---
title: C++ on Sea Presentations 2025
mathjax: false
toc: true
categories:
  - Reading
tags:
  - cpp
date: 2025-11-10 18:12:30
description:
---

# cpponsea 2025

[github.com/philsquared/cpponsea2025-slides](https://github.com/philsquared/cpponsea2025-slides)

‍

用到的 #prompt#

总结一下 PPT 中的内容，对于每个观点，保留必要的能表达作者意图的代码片段和图片。

---

# C++_Performance_Tips

​#c++/perf#

[C++_Performance_Tips](https://github.com/philsquared/cpponsea2025-slides/blob/main/Presentations/C++_Performance_Tips.pdf)

## 个人总结

1. 避免不必要的对象构造，充分利用移动语义和 RVO；
2. 用 `std::string_view`​ `std::span`；
3. 返回 `const &`​ 这个一般实用，返回值接收处很容易用 `auto` 接下来，最后还是拷贝了，所以重的类型应该是提供 accessor 或者 visitor 而不是返回数据本体，直接返回还暴露的实现细节；
4. 能预知的信息要充分利用：最终大小已知或者有预估的用 `reserve`​，编译期已知的用 `constexpr`​ `std::array`；
5. in place construction

    1. ​`std::optional`

        ```cpp
        template< class... Args > 
        constexpr explicit optional( std::in_place_t, Args&&... args );
        ```
    2. ​`std::variant`

        ```cpp
        template <class T, class... Args>
        T& emplace(Args&&... args);
        ```
    3. ​`std::vector`

        ```cpp
        template< class... Args >
        reference emplace_back( Args&&... args );
        ```
    4. ​`std::map`

        这个一般人还真不会留意到，但是但凡你用一个 `const char*` 传到一个 key 是字符串类型的关联容器里面 find 一下，编译期就会教你做人了（奸笑

        ```cpp
        template< class K >
        iterator find( const K& x );
        ```
6. 还有一些编译器选项。

‍

# Namespaces 101

​#c++/namespace#

[Namespaces 101](https://github.com/philsquared/cpponsea2025-slides/blob/main/Presentations/Namespaces_101.pptx)

主要学习一下 Qualified Name Lookup 和 Unqualified Name Lookup；以及 ADL。

其他也是老生常谈。

‍

实践经验总结

- ​**应该做**：

  - 使用命名空间分组相关代码
  - 在.cpp 文件中使用 using 声明
  - 必要时使用命名空间别名
  - 可以使用内联命名空间进行版本控制
- ​**不应该做**：

  - 在头文件中使用 `using namespace std;`
  - 过度嵌套而没有合理原因
  - 假设读者知道符号的来源
  - 将所有内容都放入 util 命名空间

## 关键要点总结

1. **使用命名空间预防名称冲突**并组织代码结构
2. **避免污染命名空间**，保持作用域清晰
3. **优先使用细粒度的嵌套命名空间**而不是大型单体命名空间
4. **保持命名一致且有意义**
5. **限制嵌套层级**（通常不超过 4 级）
6. **在宏中始终使用完全限定名称**
7. **谨慎打开外部命名空间**，这可能表示设计问题

命名空间是 C++ 中强大的代码组织工具，正确使用可以显著提高代码的可维护性和可读性，同时减少潜在的命名冲突问题。

‍

# Safe_and_Readable_Code

​#monad#​ #functor#

[Safe_and_Readable_Code](https://github.com/philsquared/cpponsea2025-slides/blob/main/Presentations/Safe_and_Readable_Code.pdf)

关于 functor，函数式编程，强调函数的表达能力，可组合性。

‍

## 核心价值

1. **代码清晰性**：复杂操作链的可读性大幅提升
2. **可组合性**：操作符的模块化组合能力
3. **安全性**：编译时检查减少运行时错误

## C++23 新特性优势

- ​`optional::and_then`​/`transform`：可选值链式处理
- ​`expected::or_else`：丰富错误处理能力
- Ranges 视图：惰性求值集合操作

## 学习路径建议

1. 从 `std::optional` ​的 Monadic 操作开始
2. 掌握 Ranges 视图的组合使用
3. 理解 Functor 和 Monad 的数学概念
4. 在适当场景实践自定义 Monad

Monadic 操作代表了 C++ 向声明式、函数式编程风格的重要演进，为编写更安全、更易维护的代码提供了强大工具。

‍

# Smart_Pointers_Dumb_Mistakes

​#c++/smart_pointer#

[Smart_Pointers_Dumb_Mistakes](https://github.com/philsquared/cpponsea2025-slides/blob/main/Presentations/Smart_Pointers_Dumb_Mistakes.pdf)

太简单了，不想说了。

‍

# Variadic_Templates_and_Parameter_Packs

​#c++/variadic_template#​ #c++/parameter_pack#

[Variadic_Templates_and_Parameter_Packs](https://github.com/philsquared/cpponsea2025-slides/blob/main/Presentations/Variadic_Templates_and_Parameter_Packs.pdf)

变参模板和参数包是现代 C++ 元编程的基石，从 `C++11` 的基础功能发展到 `C++26` 的强大特性，为类型安全、代码简洁和性能优化提供了强大支持。通过合理使用这些特性，开发者可以创建更加灵活和高效的 C++ 代码库。

‍
